/*
 * This file was generated automatically by ExtUtils::ParseXS version 2.21 from the
 * contents of AfterImage.xs. Do not edit this file, edit AfterImage.xs instead.
 *
 *	ANY CHANGES MADE HERE WILL BE LOST! 
 *
 */

#line 1 "AfterImage.xs"
#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"

#include "ppport.h"

#include <libAfterImage/config.h>
#include <libAfterImage/afterbase.h>
#include <libAfterImage/afterimage.h>

/* set_output_threshold(0xffff); */

#line 23 "AfterImage.c"
#ifndef PERL_UNUSED_VAR
#  define PERL_UNUSED_VAR(var) if (0) var = var
#endif

#ifndef PERL_ARGS_ASSERT_CROAK_XS_USAGE
#define PERL_ARGS_ASSERT_CROAK_XS_USAGE assert(cv); assert(params)

/* prototype to pass -Wmissing-prototypes */
STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params);

STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params)
{
    const GV *const gv = CvGV(cv);

    PERL_ARGS_ASSERT_CROAK_XS_USAGE;

    if (gv) {
        const char *const gvname = GvNAME(gv);
        const HV *const stash = GvSTASH(gv);
        const char *const hvname = stash ? HvNAME(stash) : NULL;

        if (hvname)
            Perl_croak(aTHX_ "Usage: %s::%s(%s)", hvname, gvname, params);
        else
            Perl_croak(aTHX_ "Usage: %s(%s)", gvname, params);
    } else {
        /* Pants. I don't think that it should be possible to get here. */
        Perl_croak(aTHX_ "Usage: CODE(0x%"UVxf")(%s)", PTR2UV(cv), params);
    }
}
#undef  PERL_ARGS_ASSERT_CROAK_XS_USAGE

#ifdef PERL_IMPLICIT_CONTEXT
#define croak_xs_usage(a,b)	S_croak_xs_usage(aTHX_ a,b)
#else
#define croak_xs_usage		S_croak_xs_usage
#endif

#endif

/* NOTE: the prototype of newXSproto() is different in versions of perls,
 * so we define a portable version of newXSproto()
 */
#ifdef newXS_flags
#define newXSproto_portable(name, c_impl, file, proto) newXS_flags(name, c_impl, file, proto, 0)
#else
#define newXSproto_portable(name, c_impl, file, proto) (PL_Sv=(SV*)newXS(name, c_impl, file), sv_setpv(PL_Sv, proto), (CV*)PL_Sv)
#endif /* !defined(newXS_flags) */

#line 75 "AfterImage.c"

XS(XS_AfterImage_c_manager_create); /* prototype to pass -Wmissing-prototypes */
XS(XS_AfterImage_c_manager_create)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "path");
    {
	char*	path = (char *)SvPV_nolen(ST(0));
	ASImageManager *	RETVAL;
#line 21 "AfterImage.xs"
		{
			char* path2 = copy_replace_envvar(getenv(ASIMAGE_PATH_ENVVAR));
			if (path && path[0]) {
				RETVAL = create_image_manager(NULL, SCREEN_GAMMA, path, path2, NULL);
			} else {
				RETVAL = create_image_manager(NULL, SCREEN_GAMMA, path2, NULL);
			}
		}
#line 99 "AfterImage.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "ASImageManagerPtr", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_AfterImage_c_visual_create); /* prototype to pass -Wmissing-prototypes */
XS(XS_AfterImage_c_visual_create)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	ASVisual *	RETVAL;
#line 35 "AfterImage.xs"
		RETVAL = create_asvisual(NULL, 0, 0, NULL);
#line 121 "AfterImage.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "ASVisualPtr", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_AfterImage_c_load); /* prototype to pass -Wmissing-prototypes */
XS(XS_AfterImage_c_load)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "manager, filename");
    {
	char*	filename = (char *)SvPV_nolen(ST(1));
	ASImageManager*	manager;
	ASImage *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "ASImageManagerPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    manager = INT2PTR(ASImageManager *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"AfterImage::c_load",
			"manager", "ASImageManagerPtr");
#line 44 "AfterImage.xs"
		RETVAL = get_asimage(manager, filename, ASFLAGS_EVERYTHING, 100);
#line 154 "AfterImage.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "ASImagePtr", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_AfterImage_c_width); /* prototype to pass -Wmissing-prototypes */
XS(XS_AfterImage_c_width)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "image");
    {
	ASImage*	image;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "ASImagePtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    image = INT2PTR(ASImage *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"AfterImage::c_width",
			"image", "ASImagePtr");
#line 52 "AfterImage.xs"
		RETVAL = image->width;
#line 187 "AfterImage.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_AfterImage_c_height); /* prototype to pass -Wmissing-prototypes */
XS(XS_AfterImage_c_height)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "image");
    {
	ASImage*	image;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "ASImagePtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    image = INT2PTR(ASImage *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"AfterImage::c_height",
			"image", "ASImagePtr");
#line 60 "AfterImage.xs"
		RETVAL = image->height;
#line 219 "AfterImage.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_AfterImage_c_parse_xml); /* prototype to pass -Wmissing-prototypes */
XS(XS_AfterImage_c_parse_xml)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "manager, visual, xml_str");
    {
	ASImageManager*	manager;
	ASVisual*	visual;
	char*	xml_str = (char *)SvPV_nolen(ST(2));
	ASImage *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "ASImageManagerPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    manager = INT2PTR(ASImageManager *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"AfterImage::c_parse_xml",
			"manager", "ASImageManagerPtr");

	if (SvROK(ST(1)) && sv_derived_from(ST(1), "ASVisualPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    visual = INT2PTR(ASVisual *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"AfterImage::c_parse_xml",
			"visual", "ASVisualPtr");
#line 70 "AfterImage.xs"
#line 260 "AfterImage.c"
#line 71 "AfterImage.xs"
		{
			RETVAL = compose_asimage_xml(visual, manager, NULL, xml_str, ASFLAGS_EVERYTHING, 20, 0, NULL);
		}
#line 265 "AfterImage.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "ASImagePtr", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_AfterImage_c_create); /* prototype to pass -Wmissing-prototypes */
XS(XS_AfterImage_c_create)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "width, height");
    {
	int	width = (int)SvIV(ST(0));
	int	height = (int)SvIV(ST(1));
	ASImage *	RETVAL;
#line 82 "AfterImage.xs"
		RETVAL = create_asimage(width, height, ASIMAGE_QUALITY_TOP);
#line 289 "AfterImage.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "ASImagePtr", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_AfterImage_c_gradient); /* prototype to pass -Wmissing-prototypes */
XS(XS_AfterImage_c_gradient)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 6)
       croak_xs_usage(cv,  "visual, width, height, colors, offsets, angle");
    {
	ASVisual*	visual;
	int	width = (int)SvIV(ST(1));
	int	height = (int)SvIV(ST(2));
	SV*	colors = ST(3);
	SV*	offsets = ST(4);
	int	angle = (int)SvIV(ST(5));
	ASImage *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "ASVisualPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    visual = INT2PTR(ASVisual *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"AfterImage::c_gradient",
			"visual", "ASVisualPtr");
#line 95 "AfterImage.xs"
		I32 numcolors = 0;
		I32 numoffsets = 0;
		if (!SvROK(colors) || SvTYPE(SvRV(colors)) != SVt_PVAV
		    || (numcolors = av_len((AV *)SvRV(colors))) < 1) {
			XSRETURN_UNDEF;
		}
		if (!SvROK(offsets) || SvTYPE(SvRV(offsets)) != SVt_PVAV
		    || (numoffsets = av_len((AV *)SvRV(offsets))) < 1) {
			XSRETURN_UNDEF;
		}
		numcolors++;
		numoffsets++;
		numoffsets = numcolors = numoffsets < numcolors ? numoffsets : numcolors;
#line 338 "AfterImage.c"
#line 109 "AfterImage.xs"
		{
			int n, reverse = 0;
			ASGradient gradient;
			angle = (angle % 360 + 360) % 360;
			if (angle > 360 * 15 / 16 || angle < 360 * 1 / 16) {
				gradient.type = GRADIENT_Left2Right;
			} else if (angle < 360 * 3 / 16) {
				gradient.type = GRADIENT_TopLeft2BottomRight;
			} else if (angle < 360 * 5 / 16) {
				gradient.type = GRADIENT_Top2Bottom;
			} else if (angle < 360 * 7 / 16) {
				gradient.type = GRADIENT_BottomLeft2TopRight; reverse = 1;
			} else if (angle < 360 * 9 / 16) {
				gradient.type = GRADIENT_Left2Right; reverse = 1;
			} else if (angle < 360 * 11 / 16) {
				gradient.type = GRADIENT_TopLeft2BottomRight; reverse = 1;
			} else if (angle < 360 * 13 / 16) {
				gradient.type = GRADIENT_Top2Bottom; reverse = 1;
			} else {
				gradient.type = GRADIENT_BottomLeft2TopRight;
			}
			gradient.color = safecalloc(numoffsets, sizeof(ARGB32));
			gradient.offset = NEW_ARRAY(double, numoffsets);
			gradient.npoints = numoffsets;
			for (n = 0 ; n < numoffsets ; n++) {
				char* color = SvPV_nolen(*av_fetch((AV *)SvRV(colors), n, 0));
				parse_argb_color(color, gradient.color + n);
				gradient.offset[n] = SvNV(*av_fetch((AV *)SvRV(offsets), n, 0));
			}
			if (reverse) {
				for (n = 0 ; n < gradient.npoints / 2 ; n++) {
					int i2 = gradient.npoints - 1 - n;
					ARGB32 c = gradient.color[n];
					double o = gradient.offset[n];
					gradient.color[n] = gradient.color[i2];
					gradient.color[i2] = c;
					gradient.offset[n] = 1.0 - gradient.offset[i2];
					gradient.offset[i2] = 1.0 - o;
				}
			}
			RETVAL = make_gradient(visual, &gradient, width, height, SCL_DO_ALL, ASA_ASImage, 0, ASIMAGE_QUALITY_TOP);
			free(gradient.color);
			free(gradient.offset);
		}
#line 384 "AfterImage.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "ASImagePtr", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_AfterImage_c_solid); /* prototype to pass -Wmissing-prototypes */
XS(XS_AfterImage_c_solid)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 4)
       croak_xs_usage(cv,  "visual, width, height, color");
    {
	ASVisual*	visual;
	int	width = (int)SvIV(ST(1));
	int	height = (int)SvIV(ST(2));
	char*	color = (char *)SvPV_nolen(ST(3));
	ASImage *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "ASVisualPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    visual = INT2PTR(ASVisual *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"AfterImage::c_solid",
			"visual", "ASVisualPtr");
#line 163 "AfterImage.xs"
		{
			ASImage* result = create_asimage(width, height, ASIMAGE_QUALITY_TOP);
			ARGB32 argb;
			parse_argb_color(color, &argb);
			if (result) fill_asimage(visual, result, 0, 0, width, height, argb);
			RETVAL = result;
		}
#line 425 "AfterImage.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "ASImagePtr", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_AfterImage_c_composite); /* prototype to pass -Wmissing-prototypes */
XS(XS_AfterImage_c_composite)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 6)
       croak_xs_usage(cv,  "visual, images, width, height, op, options");
    {
	ASVisual*	visual;
	SV*	images = ST(1);
	int	width = (int)SvIV(ST(2));
	int	height = (int)SvIV(ST(3));
	char*	op = (char *)SvPV_nolen(ST(4));
	SV*	options = ST(5);
	ASImage *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "ASVisualPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    visual = INT2PTR(ASVisual *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"AfterImage::c_composite",
			"visual", "ASVisualPtr");
#line 201 "AfterImage.xs"
		int numimages;
		int numoptions = 0;
		if (!SvROK(images) || SvTYPE(SvRV(images)) != SVt_PVAV
		    || (numimages = av_len((AV *)SvRV(images))) < 0) {
			XSRETURN_UNDEF;
		}
		if (SvROK(options) && SvTYPE(SvRV(options)) == SVt_PVAV) {
			numoptions = av_len((AV *)SvRV(options)) + 1;
		}
		numimages++;
#line 471 "AfterImage.c"
#line 212 "AfterImage.xs"
		{
			ASImage* result;
			ASImageLayer *layers = create_image_layers(numimages);
			int i;
			merge_scanlines_func op_func = blend_scanlines_name2func(op);
			if (!visual || !result || !layers || !op_func) XSRETURN_UNDEF;

			for (i = 0 ; i < numimages ; i++) {
				SV* imref = *av_fetch((AV *)SvRV(images), numimages - 1 - i, 0);
				if (sv_derived_from(imref, "ASImagePtr")) {
					IV tmp = SvIV(SvRV(imref));
					layers[i].im = INT2PTR(ASImage *, tmp);
				} else {
					Perl_croak(aTHX_ "image layer is not of type ASImagePtr");
				}
				layers[i].clip_width = layers[i].im->width;
				layers[i].clip_height = layers[i].im->height;
				layers[i].merge_scanlines = op_func;
				if (numoptions > numimages - 1 - i) {
					SV* opt_hashref = *av_fetch((AV *)SvRV(options), numimages - 1 - i, 0);
					HV* opt_hash;
					SV** tmp;
					if (!SvROK(opt_hashref) || SvTYPE(SvRV(opt_hashref)) != SVt_PVHV)
						Perl_croak(aTHX_ "image option is not of type HashRef");
					opt_hash = (HV*)SvRV(opt_hashref);
					tmp = hv_fetch(opt_hash, "x", 1, 0);
					if (tmp) layers[i].dst_x = SvIV(*tmp);
					tmp = hv_fetch(opt_hash, "y", 1, 0);
					if (tmp) layers[i].dst_y = SvIV(*tmp);
					tmp = hv_fetch(opt_hash, "clip_x", 6, 0);
					if (tmp) layers[i].clip_x = SvIV(*tmp);
					tmp = hv_fetch(opt_hash, "clip_y", 6, 0);
					if (tmp) layers[i].clip_y = SvIV(*tmp);
					tmp = hv_fetch(opt_hash, "clip_width", 10, 0);
					if (tmp) layers[i].clip_width = SvIV(*tmp);
					tmp = hv_fetch(opt_hash, "clip_height", 11, 0);
					if (tmp) layers[i].clip_height = SvIV(*tmp);
					tmp = hv_fetch(opt_hash, "tint", 4, 0);
					if (tmp) {
						ARGB32 argb;
						if (parse_argb_color(SvPV_nolen(*tmp), &argb))
							layers[i].tint = argb;
					}
					tmp = hv_fetch(opt_hash, "op", 2, 0);
					if (tmp) {
						merge_scanlines_func layer_op_func = blend_scanlines_name2func(SvPV_nolen(*tmp));
						if (layer_op_func) layers[i].merge_scanlines = layer_op_func;
					}
				}
			}
			if (!width) width = layers[numimages-1].clip_width;
			if (!height) height = layers[numimages-1].clip_height;

			RETVAL = merge_layers(
				visual, layers, numimages, width, height, ASA_ASImage, 0, 
				ASIMAGE_QUALITY_TOP
			);
		}
#line 531 "AfterImage.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "ASImagePtr", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_AfterImage_c_scale); /* prototype to pass -Wmissing-prototypes */
XS(XS_AfterImage_c_scale)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 4)
       croak_xs_usage(cv,  "visual, im, width, height");
    {
	ASVisual*	visual;
	ASImage*	im;
	int	width = (int)SvIV(ST(2));
	int	height = (int)SvIV(ST(3));
	ASImage *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "ASVisualPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    visual = INT2PTR(ASVisual *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"AfterImage::c_scale",
			"visual", "ASVisualPtr");

	if (SvROK(ST(1)) && sv_derived_from(ST(1), "ASImagePtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    im = INT2PTR(ASImage *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"AfterImage::c_scale",
			"im", "ASImagePtr");
#line 280 "AfterImage.xs"
		RETVAL = scale_asimage(visual, im, width, height, ASA_ASImage, 0, ASIMAGE_QUALITY_TOP);
#line 575 "AfterImage.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "ASImagePtr", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_AfterImage_c_pad); /* prototype to pass -Wmissing-prototypes */
XS(XS_AfterImage_c_pad)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 6)
       croak_xs_usage(cv,  "visual, im, x, y, width, height");
    {
	ASVisual*	visual;
	ASImage*	im;
	int	x = (int)SvIV(ST(2));
	int	y = (int)SvIV(ST(3));
	int	width = (int)SvIV(ST(4));
	int	height = (int)SvIV(ST(5));
	ASImage *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "ASVisualPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    visual = INT2PTR(ASVisual *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"AfterImage::c_pad",
			"visual", "ASVisualPtr");

	if (SvROK(ST(1)) && sv_derived_from(ST(1), "ASImagePtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    im = INT2PTR(ASImage *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"AfterImage::c_pad",
			"im", "ASImagePtr");
#line 293 "AfterImage.xs"
		RETVAL = pad_asimage(visual, im, x, y, width, height, 0, ASA_ASImage, 0, ASIMAGE_QUALITY_TOP);
#line 621 "AfterImage.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "ASImagePtr", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_AfterImage_c_tile); /* prototype to pass -Wmissing-prototypes */
XS(XS_AfterImage_c_tile)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 6)
       croak_xs_usage(cv,  "visual, im, x, y, width, height");
    {
	ASVisual*	visual;
	ASImage*	im;
	int	x = (int)SvIV(ST(2));
	int	y = (int)SvIV(ST(3));
	int	width = (int)SvIV(ST(4));
	int	height = (int)SvIV(ST(5));
	ASImage *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "ASVisualPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    visual = INT2PTR(ASVisual *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"AfterImage::c_tile",
			"visual", "ASVisualPtr");

	if (SvROK(ST(1)) && sv_derived_from(ST(1), "ASImagePtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    im = INT2PTR(ASImage *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"AfterImage::c_tile",
			"im", "ASImagePtr");
#line 306 "AfterImage.xs"
		RETVAL = tile_asimage(visual, im, x, y, width, height, 0, ASA_ASImage, 0, ASIMAGE_QUALITY_TOP);
#line 667 "AfterImage.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "ASImagePtr", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_AfterImage_c_tint); /* prototype to pass -Wmissing-prototypes */
XS(XS_AfterImage_c_tint)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "visual, image, color");
    {
	ASVisual*	visual;
	ASImage*	image;
	char*	color = (char *)SvPV_nolen(ST(2));
	ASImage *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "ASVisualPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    visual = INT2PTR(ASVisual *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"AfterImage::c_tint",
			"visual", "ASVisualPtr");

	if (SvROK(ST(1)) && sv_derived_from(ST(1), "ASImagePtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    image = INT2PTR(ASImage *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"AfterImage::c_tint",
			"image", "ASImagePtr");
#line 316 "AfterImage.xs"
		{
			ARGB32 argb;
			parse_argb_color(color, &argb);
			RETVAL = tile_asimage(visual, image, 0, 0, image->width, image->height, argb, ASA_ASImage, 0, ASIMAGE_QUALITY_TOP);
		}
#line 714 "AfterImage.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "ASImagePtr", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_AfterImage_c_draw_text); /* prototype to pass -Wmissing-prototypes */
XS(XS_AfterImage_c_draw_text)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 5)
       croak_xs_usage(cv,  "visual, font, text, color, type_3d");
    {
	ASVisual*	visual;
	ASFont*	font;
	char*	text = (char *)SvPV_nolen(ST(2));
	char*	color = (char *)SvPV_nolen(ST(3));
	int	type_3d = (int)SvIV(ST(4));
	ASImage *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "ASVisualPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    visual = INT2PTR(ASVisual *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"AfterImage::c_draw_text",
			"visual", "ASVisualPtr");

	if (SvROK(ST(1)) && sv_derived_from(ST(1), "ASFontPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    font = INT2PTR(ASFont *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"AfterImage::c_draw_text",
			"font", "ASFontPtr");
#line 332 "AfterImage.xs"
		{
			ASTextAttributes attr = { ASTA_VERSION_INTERNAL, 0, 0, ASCT_Char, 8, 0, NULL, 0, ARGB32_White }; 
			ARGB32 argb;
			ASImage* text_color_image;
			ASImage* text_image;
			parse_argb_color(color, &argb);
			attr.char_type = ASCT_UTF8;
			attr.type = type_3d;
			text_image = draw_fancy_text(text, font, &attr, 0, 0);
			text_color_image = create_asimage(text_image->width, text_image->height, ASIMAGE_QUALITY_TOP);
			fill_asimage(visual, text_color_image, 0, 0, text_image->width, text_image->height, argb);
			move_asimage_channel(text_color_image, IC_ALPHA, text_image, IC_ALPHA);
			safe_asimage_destroy(text_image);
			RETVAL = text_color_image;
		}
#line 773 "AfterImage.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "ASImagePtr", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_AfterImage_c_gaussian_blur); /* prototype to pass -Wmissing-prototypes */
XS(XS_AfterImage_c_gaussian_blur)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 4)
       croak_xs_usage(cv,  "visual, image, x_radius, y_radius");
    {
	ASVisual*	visual;
	ASImage*	image;
	double	x_radius = (double)SvNV(ST(2));
	double	y_radius = (double)SvNV(ST(3));
	ASImage *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "ASVisualPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    visual = INT2PTR(ASVisual *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"AfterImage::c_gaussian_blur",
			"visual", "ASVisualPtr");

	if (SvROK(ST(1)) && sv_derived_from(ST(1), "ASImagePtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    image = INT2PTR(ASImage *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"AfterImage::c_gaussian_blur",
			"image", "ASImagePtr");
#line 357 "AfterImage.xs"
		RETVAL = blur_asimage_gauss(visual, image, x_radius, y_radius, SCL_DO_ALL, ASA_ASImage, 0, ASIMAGE_QUALITY_TOP);
#line 817 "AfterImage.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "ASImagePtr", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_AfterImage_c_rotate); /* prototype to pass -Wmissing-prototypes */
XS(XS_AfterImage_c_rotate)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "visual, image, angle");
    {
	ASVisual*	visual;
	ASImage*	image;
	double	angle = (double)SvNV(ST(2));
	ASImage *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "ASVisualPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    visual = INT2PTR(ASVisual *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"AfterImage::c_rotate",
			"visual", "ASVisualPtr");

	if (SvROK(ST(1)) && sv_derived_from(ST(1), "ASImagePtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    image = INT2PTR(ASImage *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"AfterImage::c_rotate",
			"image", "ASImagePtr");
#line 376 "AfterImage.xs"
		{
			int int_angle = ((int)angle % 360 + 360 + 45) % 360 / 90 * 90;
			int width = image->width;
			int height = image->height;
			int flip_flags = 0;
			if (int_angle == 90 || int_angle == 270) {
				width = image->height;
				height = image->width;
			}
			switch (int_angle) {
				case  90: flip_flags = FLIP_VERTICAL; break;
				case 180: flip_flags = FLIP_UPSIDEDOWN; break;
				case 270: flip_flags = FLIP_VERTICAL | FLIP_UPSIDEDOWN; break;
				default:  flip_flags = 0;
			}
			if (flip_flags) {
				RETVAL = flip_asimage(visual, image, 0, 0, width, height, flip_flags, ASA_ASImage, 0, ASIMAGE_QUALITY_TOP);
			} else {
				image->ref_count++;
				RETVAL = image;
			}
		}
#line 881 "AfterImage.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "ASImagePtr", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_AfterImage_c_mirror); /* prototype to pass -Wmissing-prototypes */
XS(XS_AfterImage_c_mirror)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "visual, image, vertical");
    {
	ASVisual*	visual;
	ASImage*	image;
	int	vertical = (int)SvIV(ST(2));
	ASImage *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "ASVisualPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    visual = INT2PTR(ASVisual *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"AfterImage::c_mirror",
			"visual", "ASVisualPtr");

	if (SvROK(ST(1)) && sv_derived_from(ST(1), "ASImagePtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    image = INT2PTR(ASImage *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"AfterImage::c_mirror",
			"image", "ASImagePtr");
#line 412 "AfterImage.xs"
		RETVAL = mirror_asimage(visual, image, 0, 0, image->width, image->height, vertical, ASA_ASImage, 0, ASIMAGE_QUALITY_TOP);
#line 924 "AfterImage.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "ASImagePtr", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_AfterImage_c_draw_filled_rectangle); /* prototype to pass -Wmissing-prototypes */
XS(XS_AfterImage_c_draw_filled_rectangle)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 7)
       croak_xs_usage(cv,  "visual, im, x, y, width, height, color");
    {
	ASVisual*	visual;
	ASImage*	im;
	int	x = (int)SvIV(ST(2));
	int	y = (int)SvIV(ST(3));
	int	width = (int)SvIV(ST(4));
	int	height = (int)SvIV(ST(5));
	char*	color = (char *)SvPV_nolen(ST(6));
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "ASVisualPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    visual = INT2PTR(ASVisual *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"AfterImage::c_draw_filled_rectangle",
			"visual", "ASVisualPtr");

	if (SvROK(ST(1)) && sv_derived_from(ST(1), "ASImagePtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    im = INT2PTR(ASImage *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"AfterImage::c_draw_filled_rectangle",
			"im", "ASImagePtr");
#line 426 "AfterImage.xs"
		{
			ARGB32 argb;
			parse_argb_color(color, &argb);
			RETVAL = fill_asimage(visual, im, x, y, width, height, argb);
		}
#line 976 "AfterImage.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_AfterImage_c_clone); /* prototype to pass -Wmissing-prototypes */
XS(XS_AfterImage_c_clone)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "im");
    {
	ASImage*	im;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "ASImagePtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    im = INT2PTR(ASImage *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"AfterImage::c_clone",
			"im", "ASImagePtr");
#line 438 "AfterImage.xs"
		RETVAL = asimage_clone(im, 0x7fffffff);
#line 1008 "AfterImage.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_AfterImage_c_release); /* prototype to pass -Wmissing-prototypes */
XS(XS_AfterImage_c_release)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "im");
    {
	ASImage*	im;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "ASImagePtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    im = INT2PTR(ASImage *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"AfterImage::c_release",
			"im", "ASImagePtr");
#line 446 "AfterImage.xs"
		RETVAL = release_asimage(im);
#line 1040 "AfterImage.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_AfterImage_c_save); /* prototype to pass -Wmissing-prototypes */
XS(XS_AfterImage_c_save)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 5)
       croak_xs_usage(cv,  "im, filename, type, compression, opacity");
    {
	ASImage*	im;
	char*	filename = (char *)SvPV_nolen(ST(1));
	char*	type = (char *)SvPV_nolen(ST(2));
	char*	compression = (char *)SvPV_nolen(ST(3));
	char*	opacity = (char *)SvPV_nolen(ST(4));
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "ASImagePtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    im = INT2PTR(ASImage *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"AfterImage::c_save",
			"im", "ASImagePtr");
#line 458 "AfterImage.xs"
		RETVAL = save_asimage_to_file(filename, im, type, compression, opacity, 0, 1);
#line 1076 "AfterImage.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_AfterImage__Font_c_manager_create); /* prototype to pass -Wmissing-prototypes */
XS(XS_AfterImage__Font_c_manager_create)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "path");
    {
	char*	path = (char *)SvPV_nolen(ST(0));
	ASFontManager *	RETVAL;
#line 470 "AfterImage.xs"
		RETVAL = create_font_manager(NULL, path, NULL);
#line 1098 "AfterImage.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "ASFontManagerPtr", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_AfterImage__Font_c_open); /* prototype to pass -Wmissing-prototypes */
XS(XS_AfterImage__Font_c_open)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "manager, font_name, points");
    {
	ASFontManager*	manager;
	char*	font_name = (char *)SvPV_nolen(ST(1));
	int	points = (int)SvIV(ST(2));
	ASFont *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "ASFontManagerPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    manager = INT2PTR(ASFontManager *,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"AfterImage::Font::c_open",
			"manager", "ASFontManagerPtr");
#line 480 "AfterImage.xs"
		RETVAL = get_asfont(manager, font_name, 0, points, ASF_GuessWho);
#line 1132 "AfterImage.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "ASFontPtr", (void*)RETVAL);
    }
    XSRETURN(1);
}

#ifdef __cplusplus
extern "C"
#endif
XS(boot_AfterImage); /* prototype to pass -Wmissing-prototypes */
XS(boot_AfterImage)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
#if (PERL_REVISION == 5 && PERL_VERSION < 9)
    char* file = __FILE__;
#else
    const char* file = __FILE__;
#endif

    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(items); /* -W */
    XS_VERSION_BOOTCHECK ;

        (void)newXS("AfterImage::c_manager_create", XS_AfterImage_c_manager_create, file);
        (void)newXS("AfterImage::c_visual_create", XS_AfterImage_c_visual_create, file);
        (void)newXS("AfterImage::c_load", XS_AfterImage_c_load, file);
        (void)newXS("AfterImage::c_width", XS_AfterImage_c_width, file);
        (void)newXS("AfterImage::c_height", XS_AfterImage_c_height, file);
        (void)newXS("AfterImage::c_parse_xml", XS_AfterImage_c_parse_xml, file);
        (void)newXS("AfterImage::c_create", XS_AfterImage_c_create, file);
        (void)newXS("AfterImage::c_gradient", XS_AfterImage_c_gradient, file);
        (void)newXS("AfterImage::c_solid", XS_AfterImage_c_solid, file);
        (void)newXS("AfterImage::c_composite", XS_AfterImage_c_composite, file);
        (void)newXS("AfterImage::c_scale", XS_AfterImage_c_scale, file);
        (void)newXS("AfterImage::c_pad", XS_AfterImage_c_pad, file);
        (void)newXS("AfterImage::c_tile", XS_AfterImage_c_tile, file);
        (void)newXS("AfterImage::c_tint", XS_AfterImage_c_tint, file);
        (void)newXS("AfterImage::c_draw_text", XS_AfterImage_c_draw_text, file);
        (void)newXS("AfterImage::c_gaussian_blur", XS_AfterImage_c_gaussian_blur, file);
        (void)newXS("AfterImage::c_rotate", XS_AfterImage_c_rotate, file);
        (void)newXS("AfterImage::c_mirror", XS_AfterImage_c_mirror, file);
        (void)newXS("AfterImage::c_draw_filled_rectangle", XS_AfterImage_c_draw_filled_rectangle, file);
        (void)newXS("AfterImage::c_clone", XS_AfterImage_c_clone, file);
        (void)newXS("AfterImage::c_release", XS_AfterImage_c_release, file);
        (void)newXS("AfterImage::c_save", XS_AfterImage_c_save, file);
        (void)newXS("AfterImage::Font::c_manager_create", XS_AfterImage__Font_c_manager_create, file);
        (void)newXS("AfterImage::Font::c_open", XS_AfterImage__Font_c_open, file);
#if (PERL_REVISION == 5 && PERL_VERSION >= 9)
  if (PL_unitcheckav)
       call_list(PL_scopestack_ix, PL_unitcheckav);
#endif
    XSRETURN_YES;
}

